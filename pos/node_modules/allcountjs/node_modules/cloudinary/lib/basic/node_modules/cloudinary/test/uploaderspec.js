// Generated by CoffeeScript 1.9.3
(function() {
  var cloudinary, dotenv, expect, fs, http, https;

  dotenv = require('dotenv');

  dotenv.load();

  https = require('https');

  http = require('http');

  expect = require("expect.js");

  cloudinary = require("../cloudinary");

  fs = require('fs');

  describe("uploader", function() {
    if (cloudinary.config().api_secret == null) {
      return console.warn("**** Please setup environment for uploader test to run!");
    }
    beforeEach(function() {
      return cloudinary.config(true);
    });
    it("should successfully upload file", function(done) {
      this.timeout(5000);
      return cloudinary.v2.uploader.upload("test/logo.png", function(error, result) {
        var expected_signature;
        if (error != null) {
          return done(new Error(error.message));
        }
        expect(result.width).to.eql(241);
        expect(result.height).to.eql(51);
        expected_signature = cloudinary.utils.api_sign_request({
          public_id: result.public_id,
          version: result.version
        }, cloudinary.config().api_secret);
        expect(result.signature).to.eql(expected_signature);
        return cloudinary.v2.uploader.destroy(result.public_id, function(derror, dresult) {
          if (derror != null) {
            return done(new Error(derror.message));
          }
          expect(dresult.result).to.eql("ok");
          return done();
        });
      });
    });
    it("should successfully upload url", function(done) {
      this.timeout(5000);
      return cloudinary.uploader.upload("http://cloudinary.com/images/old_logo.png", function(result) {
        var expected_signature;
        if (result.error != null) {
          return done(new Error(result.error.message));
        }
        expect(result.width).to.eql(241);
        expect(result.height).to.eql(51);
        expected_signature = cloudinary.utils.api_sign_request({
          public_id: result.public_id,
          version: result.version
        }, cloudinary.config().api_secret);
        expect(result.signature).to.eql(expected_signature);
        return done();
      });
    });
    it("should successfully rename a file", function(done) {
      this.timeout(25000);
      return cloudinary.v2.uploader.upload("test/logo.png", function(error, result) {
        if (error != null) {
          return done(new Error(error.message));
        }
        return cloudinary.v2.uploader.rename(result.public_id, result.public_id + "2", function(e1, r1) {
          if (e1 != null) {
            return done(new Error(e1.message));
          }
          return cloudinary.v2.api.resource(result.public_id + "2", function(e2, r2) {
            expect(e2).to.be(void 0);
            return cloudinary.v2.uploader.upload("test/favicon.ico", function(error2, result2) {
              return cloudinary.v2.uploader.rename(result2.public_id, result.public_id + "2", function(e3, r3) {
                expect(e3).not.to.be(void 0);
                return cloudinary.v2.uploader.rename(result2.public_id, result.public_id + "2", {
                  overwrite: true
                }, function(e4, r4) {
                  return cloudinary.v2.api.resource(result.public_id + "2", function(e5, r5) {
                    expect(r5.format).to.eql("ico");
                    return done();
                  });
                });
              });
            });
          });
        });
      });
    });
    it("should successfully call explicit api", function(done) {
      var current;
      this.timeout(5000);
      current = this;
      return cloudinary.v2.uploader.explicit("cloudinary", {
        type: "twitter_name",
        eager: [
          {
            crop: "scale",
            width: "2.0"
          }
        ]
      }, function(error, result) {
        var url;
        if (error == null) {
          url = cloudinary.utils.url("cloudinary", {
            type: "twitter_name",
            crop: "scale",
            width: "2.0",
            format: "png",
            version: result["version"]
          });
          expect(result.eager[0].url).to.eql(url);
          return done();
        } else {
          if (error.code === 420) {
            console.warn(error.message);
            console.warn("Try running '" + current.test.title + "' again in 10 minutes");
            current.test.pending = true;
            return done();
          } else {
            return done(new Error(error.message));
          }
        }
      });
    });
    it("should support eager in upload", function(done) {
      this.timeout(5000);
      return cloudinary.uploader.upload("test/logo.png", function(result) {
        if (result.error != null) {
          return done(new Error(result.error.message));
        }
        return done();
      }, {
        eager: [
          {
            crop: "scale",
            width: "2.0"
          }
        ]
      });
    });
    it("should support custom headers in upload", function(done) {
      this.timeout(5000);
      return cloudinary.uploader.upload("test/logo.png", function(result) {
        if (result.error != null) {
          return done(new Error(result.error.message));
        }
        return cloudinary.uploader.upload("test/logo.png", function(result) {
          if (result.error != null) {
            return done(new Error(result.error.message));
          }
          return done();
        }, {
          headers: {
            Link: "1"
          }
        });
      }, {
        headers: ["Link: 1"]
      });
    });
    it("should successfully generate text image", function(done) {
      this.timeout(5000);
      return cloudinary.v2.uploader.text("hello world", function(error, result) {
        if (error != null) {
          return done(new Error(error.message));
        }
        expect(result.width).to.within(50, 70);
        expect(result.height).to.within(5, 15);
        return done();
      });
    });
    it("should successfully upload stream", function(done) {
      var file_reader, stream;
      this.timeout(5000);
      stream = cloudinary.v2.uploader.upload_stream(function(error, result) {
        var expected_signature;
        if (error != null) {
          return done(new Error(error.message));
        }
        expect(result.width).to.eql(241);
        expect(result.height).to.eql(51);
        expected_signature = cloudinary.utils.api_sign_request({
          public_id: result.public_id,
          version: result.version
        }, cloudinary.config().api_secret);
        expect(result.signature).to.eql(expected_signature);
        return done();
      });
      file_reader = fs.createReadStream('test/logo.png', {
        encoding: 'binary'
      });
      file_reader.on('data', function(chunk) {
        return stream.write(chunk, 'binary');
      });
      return file_reader.on('end', function() {
        return stream.end();
      });
    });
    it("should successfully manipulate tags", function(done) {
      this.timeout(15000);
      return cloudinary.v2.uploader.upload("test/logo.png", function(error1, result1) {
        return cloudinary.v2.uploader.upload("test/logo.png", function(error2, result2) {
          if (error1 != null) {
            return done(new Error(error1.message));
          }
          if (error2 != null) {
            return done(new Error(error2.message));
          }
          return cloudinary.v2.uploader.add_tag("tag1", [result1.public_id, result2.public_id], function(et1, rt1) {
            if (et1 != null) {
              return done(new Error(et1.message));
            }
            return cloudinary.api.resource(result2.public_id, function(r1) {
              expect(r1.tags).to.eql(["tag1"]);
              return cloudinary.uploader.add_tag("tag2", result1.public_id, function() {
                return cloudinary.v2.api.resource(result1.public_id, function(e1, r1) {
                  expect(r1.tags).to.eql(["tag1", "tag2"]);
                  return cloudinary.v2.uploader.remove_tag("tag1", result1.public_id, function() {
                    return cloudinary.api.resource(result1.public_id, function(r2) {
                      expect(r2.tags).to.eql(["tag2"]);
                      return cloudinary.v2.uploader.replace_tag("tag3Å", result1.public_id, function() {
                        return cloudinary.api.resource(result1.public_id, function(r3) {
                          expect(r3.tags).to.eql(["tag3Å"]);
                          return done();
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
    it("should support timeouts", function(done) {
      this.timeout(5000);
      return cloudinary.uploader.upload("http://cloudinary.com/images/old_logo.png", function(result) {
        expect(result.error.http_code).to.eql(499);
        expect(result.error.message).to.eql("Request Timeout");
        return done();
      }, {
        timeout: 1
      });
    });
    it("should upload a file and base public id on the filename if use_filename is set to true", function(done) {
      this.timeout(10000);
      return cloudinary.uploader.upload("test/logo.png", function(result) {
        if (result.error != null) {
          return done(new Error(result.error.message));
        }
        expect(result.public_id).to.match(/logo_[a-zA-Z0-9]{6}/);
        return cloudinary.uploader.destroy(result.public_id, function(dresult) {
          if (dresult.error != null) {
            return done(new Error(dresult.error.message));
          }
          expect(dresult.result).to.eql("ok");
          return done();
        });
      }, {
        use_filename: true
      });
    });
    it("should upload a file and set the filename as the public_id if use_filename is set to true and unique_filename is set to false", function(done) {
      this.timeout(5000);
      return cloudinary.uploader.upload("test/logo.png", function(result) {
        if (result.error != null) {
          return done(new Error(result.error.message));
        }
        expect(result.public_id).to.eql("logo");
        return cloudinary.uploader.destroy(result.public_id, function(dresult) {
          if (dresult.error != null) {
            return done(new Error(dresult.error.message));
          }
          expect(dresult.result).to.eql("ok");
          return done();
        });
      }, {
        use_filename: true,
        unique_filename: false
      });
    });
    it("should allow whitelisted formats if allowed_formats", function(done) {
      return cloudinary.uploader.upload("test/logo.png", function(result) {
        if (result.error != null) {
          return done(new Error(result.error.message));
        }
        expect(result.format).to.eql("png");
        return done();
      }, {
        allowed_formats: ["png"]
      });
    });
    it("should prevent non whitelisted formats from being uploaded if allowed_formats is specified", function(done) {
      return cloudinary.uploader.upload("test/logo.png", function(result) {
        expect(result.error.http_code).to.eql(400);
        return done();
      }, {
        allowed_formats: ["jpg"]
      });
    });
    it("should allow non whitelisted formats if type is specified and convert to that type", function(done) {
      return cloudinary.uploader.upload("test/logo.png", function(result) {
        if (result.error != null) {
          return done(new Error(result.error.message));
        }
        expect(result.format).to.eql("jpg");
        return done();
      }, {
        allowed_formats: ["jpg"],
        format: "jpg"
      });
    });
    it("should allow sending face coordinates", function(done) {
      var coordinates, custom_coordinates, different_coordinates;
      this.timeout(5000);
      coordinates = [[120, 30, 109, 150], [121, 31, 110, 151]];
      different_coordinates = [[122, 32, 111, 152]];
      custom_coordinates = [1, 2, 3, 4];
      return cloudinary.v2.uploader.upload("test/logo.png", {
        face_coordinates: coordinates,
        faces: true
      }, function(error, result) {
        if (error != null) {
          return done(new Error(error.message));
        }
        expect(result.faces).to.eql(coordinates);
        return cloudinary.v2.uploader.explicit(result.public_id, {
          face_coordinates: different_coordinates,
          custom_coordinates: custom_coordinates,
          type: "upload"
        }, function(error2, result2) {
          if (error2 != null) {
            return done(new Error(error2.message));
          }
          return cloudinary.v2.api.resource(result2.public_id, {
            faces: true,
            coordinates: true
          }, function(ierror, info) {
            if (ierror != null) {
              return done(new Error(ierror.message));
            }
            expect(info.faces).to.eql(different_coordinates);
            expect(info.coordinates).to.eql({
              faces: different_coordinates,
              custom: [custom_coordinates]
            });
            return done();
          });
        });
      });
    });
    it("should allow sending context", function(done) {
      var context;
      this.timeout(5000);
      context = {
        caption: "some caption",
        alt: "alternative"
      };
      return cloudinary.uploader.upload("test/logo.png", function(result) {
        if (result.error != null) {
          return done(new Error(result.error.message));
        }
        return cloudinary.api.resource(result.public_id, function(info) {
          if (info.error != null) {
            return done(new Error(info.error.message));
          }
          expect(info.context.custom.caption).to.eql("some caption");
          expect(info.context.custom.alt).to.eql("alternative");
          return done();
        }, {
          context: true
        });
      }, {
        context: context
      });
    });
    it("should support requesting manual moderation", function(done) {
      this.timeout(5000);
      return cloudinary.uploader.upload("test/logo.png", function(result) {
        expect(result.moderation[0].status).to.eql("pending");
        expect(result.moderation[0].kind).to.eql("manual");
        return done();
      }, {
        moderation: "manual"
      });
    });
    it("should support requesting raw conversion", function(done) {
      this.timeout(5000);
      return cloudinary.uploader.upload("test/docx.docx", function(result) {
        expect(result.error != null).to.be(true);
        expect(result.error.message).to.contain("is not a valid");
        return done();
      }, {
        raw_convert: "illegal",
        resource_type: "raw"
      });
    });
    it("should support requesting categorization", function(done) {
      this.timeout(5000);
      return cloudinary.uploader.upload("test/logo.png", function(result) {
        expect(result.error != null).to.be(true);
        expect(result.error.message).to.contain("is not a valid");
        return done();
      }, {
        categorization: "illegal"
      });
    });
    it("should support requesting detection", function(done) {
      this.timeout(5000);
      return cloudinary.uploader.upload("test/logo.png", function(result) {
        expect(result.error != null).to.be(true);
        expect(result.error.message).to.contain("is not a valid");
        return done();
      }, {
        detection: "illegal"
      });
    });
    it("should support requesting background_removal", function(done) {
      this.timeout(5000);
      return cloudinary.uploader.upload("test/logo.png", function(result) {
        expect(result.error != null).to.be(true);
        expect(result.error.message).to.contain("is invalid");
        return done();
      }, {
        background_removal: "illegal"
      });
    });
    it("should support requesting auto_tagging", function(done) {
      this.timeout(5000);
      return cloudinary.uploader.upload("test/logo.png", function(result) {
        expect(result.error != null).to.be(true);
        expect(result.error.message).to.contain("Must use");
        return done();
      }, {
        auto_tagging: 0.5
      });
    });
    it("should support uploading large raw files", function(done) {
      this.timeout(5000);
      return fs.stat("test/docx.docx", function(err, stat) {
        return cloudinary.uploader.upload_large("test/docx.docx", function(response) {
          expect(response.bytes).to.eql(stat.size);
          return done();
        });
      });
    });
    describe("chunk_size:", function() {
      it("should specify chunk size", function(done) {
        this.timeout(500000);
        return fs.stat("test/TheCompleteWorksOfShakespeare.mobi", function(err, stat) {
          return cloudinary.uploader.upload_large("test/TheCompleteWorksOfShakespeare.mobi", function(response) {
            expect(response.bytes).to.eql(stat.size);
            return done();
          }, {
            chunk_size: 7000000
          });
        });
      });
      return it("should return error if value is less than 5MB", function(done) {
        this.timeout(5000);
        return fs.stat("test/TheCompleteWorksOfShakespeare.mobi", function(err, stat) {
          return cloudinary.uploader.upload_large("test/TheCompleteWorksOfShakespeare.mobi", function(response) {
            expect(response.error.message).to.eql("All parts except last must be larger than 5mb");
            return done();
          }, {
            chunk_size: 40000
          });
        });
      });
    });
    it("should support uploading large video files", function(done) {
      this.timeout(0);
      return fs.stat("test/CloudBookStudy-HD.mp4", function(err, stat) {
        return cloudinary.uploader.upload_large("test/CloudBookStudy-HD.mp4", function(response) {
          expect(response).to.not.have.property("error");
          expect(response.bytes).to.eql(stat.size);
          return done();
        });
      });
    });
    it("should support unsigned uploading using presets", function(done) {
      this.timeout(5000);
      return cloudinary.v2.api.create_upload_preset({
        folder: "upload_folder",
        unsigned: true
      }, function(error, preset) {
        return cloudinary.v2.uploader.unsigned_upload("test/logo.png", preset.name, function(error, result) {
          expect(result.public_id).to.match(/^upload_folder\/[a-z0-9]+$/);
          return cloudinary.api.delete_upload_preset(preset.name, function() {
            return done();
          });
        });
      });
    });
    it("should reject promise if error code is returned from the server", function(done) {
      this.timeout(5000);
      return cloudinary.uploader.upload("test/empty.gif").then(function() {
        return expect().fail("server should return an error when uploading an empty file");
      })["catch"](function(error) {
        return expect(error.message).to.contain("empty");
      })["finally"](function() {
        return done();
      });
    });
    it("should successfully upload with pipes", function(done) {
      var file_reader, upload;
      this.timeout(2000);
      upload = cloudinary.v2.uploader.upload_stream(function(error, result) {
        var expected_signature;
        if (error != null) {
          return done(new Error(error.message));
        }
        expect(result.width).to.eql(241);
        expect(result.height).to.eql(51);
        expected_signature = cloudinary.utils.api_sign_request({
          public_id: result.public_id,
          version: result.version
        }, cloudinary.config().api_secret);
        expect(result.signature).to.eql(expected_signature);
        return done();
      });
      file_reader = fs.createReadStream('test/logo.png');
      return file_reader.pipe(upload);
    });
    it("should fail with http.Agent (non secure)", function(done) {
      var file_reader, upload;
      this.timeout(2000);
      upload = cloudinary.v2.uploader.upload_stream({
        agent: new http.Agent
      }, function(error, result) {
        expect(error.message).to.match(/socket hang up|ECONNRESET/);
        return done();
      });
      file_reader = fs.createReadStream('test/logo.png');
      return file_reader.pipe(upload);
    });
    return it("should successfully override https agent", function(done) {
      var file_reader, upload;
      this.timeout(2000);
      upload = cloudinary.v2.uploader.upload_stream({
        agent: new https.Agent
      }, function(error, result) {
        var expected_signature;
        if (error != null) {
          return done(new Error(error.message));
        }
        expect(result.width).to.eql(241);
        expect(result.height).to.eql(51);
        expected_signature = cloudinary.utils.api_sign_request({
          public_id: result.public_id,
          version: result.version
        }, cloudinary.config().api_secret);
        expect(result.signature).to.eql(expected_signature);
        return done();
      });
      file_reader = fs.createReadStream('test/logo.png');
      return file_reader.pipe(upload);
    });
  });

}).call(this);

//# sourceMappingURL=uploaderspec.js.map
