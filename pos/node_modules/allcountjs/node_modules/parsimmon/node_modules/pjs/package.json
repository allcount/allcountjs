{
  "name": "pjs",
  "version": "5.1.1",
  "description": "A lightweight class system.  It's just prototypes!",
  "keywords": [
    "class",
    "pjs",
    "P",
    "inheritance",
    "super"
  ],
  "author": {
    "name": "Jeanine Adkisson",
    "email": "jneen at jneen dot net"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/jneen/pjs"
  },
  "files": [
    "index.js",
    "src",
    "test",
    "Makefile",
    "package.json",
    "README.md",
    "CHANGELOG.md",
    "build/p.commonjs.js"
  ],
  "main": "index.js",
  "devDependencies": {
    "mocha": "*",
    "uglify-js": "*"
  },
  "scripts": {
    "test": "make test"
  },
  "readme": "[![Build Status](https://secure.travis-ci.org/jayferd/pjs.png)](http://travis-ci.org/jayferd/pjs)\n\n# P.js\n\nP.js is a lightweight layer over javascript's built-in inheritance system that keeps all the good stuff and hides all the crap.\n\n## just show me some code already\n\nOkay.\n\n``` js\n// adapted from coffeescript.org\n// P.js exposes the `P` variable\nvar Animal = P(function(animal) {\n  animal.init = function(name) { this.name = name; };\n\n  animal.move = function(meters) {\n    console.log(this.name+\" moved \"+meters+\"m.\");\n  }\n});\n\nvar Snake = P(Animal, function(snake, animal) {\n  snake.move = function() {\n    console.log(\"Slithering...\");\n    animal.move.call(this, 5);\n  };\n});\n\nvar Horse = P(Animal, function(horse, animal) {\n  horse.move = function() {\n    console.log(\"Galloping...\");\n    animal.move.call(this, 45);\n  };\n});\n\nvar sam = Snake(\"Sammy the Python\")\n  , tom = Horse(\"Tommy the Palomino\")\n;\n\nsam.move()\ntom.move()\n```\n\n## how is pjs different from X\n\nMost class systems for JS let you define classes by passing an object.  P.js lets you pass a function instead, which allows you to closure private methods and macros.  It's also &lt;0.4kb minified (`make report`: 478).\n\n### why doesn't pjs suck?\n\nUnlike [some][prototypejs] [other][classjs] [frameworks][joose] [out][zjs] [there][structr], Pjs doesn't do any of this:\n\n- interfaces, abstract static factory factories, [and][joose] [other][prototypejs] [bloat][zjs]\n- use Object.create (it even works in IE &lt; 8!)\n- break `instanceof`\n- [hack functions onto `this` at runtime][classjs]\n- rely on magical object keys which don't minify (the only special name is `init`)\n\n[prototypejs]: http://prototypejs.org/learn/class-inheritance\n[classjs]: https://github.com/kilhage/class.js\n[zjs]: http://code.google.com/p/zjs/\n[joose]: http://joose.it\n[structr]: http://search.npmjs.org/#/structr\n\n## what can i do with pjs?\n\n- inheritable constructors (via the optional `init` method)\n- closure-based \"private\" methods (see below)\n- easily call `super` on public methods without any dirty hacks\n- instantiate your objects without calling the constructor (absolutely necessary for inheritance)\n- construct objects with variable arguments\n\n## how do i use pjs?\n\nYou can call `P` in a few different ways:\n\n``` js\n// this defines a class that inherits directly from Object.\nP(function(proto, super, class, superclass) {\n  // define private methods as regular functions that take\n  // `self` (or `me`, or `it`, or anything you really want)\n  function myPrivateMethod(self, arg1, arg2) {\n    // ...\n  }\n\n  proto.init = function() {\n    myPrivateMethod(this, 1, 2)\n  };\n\n  // you can also return an object from this function, which will\n  // be merged into the prototype.\n  return { thing: 3 };\n});\n\n// this defines a class that inherits from MySuperclass\nP(MySuperclass, function(proto, super, class, superclass) {\n  proto.init = function() {\n    // call superclass methods with super.method.call(this, ...)\n    //                           or super.method.apply(this, arguments)\n    super.init.call(this);\n  };\n});\n\n// for shorthand, you can pass an object in lieu of the function argument,\n// but you lose the niceness of super and private methods.\nP({ init: function(a) { this.thing = a } });\n\nMyClass = P(function(p) { p.init = function(a, b) { console.log(\"init!\", a, b) }; });\n// instantiate objects by calling the class as a function\nMyClass(1, 2) // => init!, 1, 2\n\n// to initialize with varargs, use `apply` like any other function.\nvar argsList = [1, 2];\nMyClass.apply(null, argsList) // init!, 1, 2\n\n// you can use it like an idiomatic class:\n// `new` is optional, not really recommended.\nnew MyClass(1, 2) // => init!, 1, 2\n// non-pjs idiomatic subclass\nfunction Subclass(a) { MyClass.call(this, a, a); }\nnew Subclass(3) // => init!, 3, 3\nnew Subclass(3) instanceof MyClass // => true\n\n// `new` may be used to \"force\" instantiation when ambiguous,\n// for example in a factory method that creates new instances\nMyClass.prototype.clone = function(a, b) {\n  return new this.constructor(a, b);\n};\n// because without `new`, `this.constructor(a, b)` is equivalent to\n// `MyClass.call(this, a, b)` which as we saw in the previous example\n// mutates `this` rather than creating new instances\n\n// allocate uninitialized objects with .Bare\n// (much like Ruby's Class#allocate)\nnew MyClass.Bare // nothing logged\nnew MyClass.Bare instanceof MyClass // => true\n\n// you can use `.open` to reopen a class.  This has the same behavior\n// as the regular definitions.\n// note that _super will still be set to the class's prototype\nMyClass = P({ a: 1 });\nvar myInst = MyClass();\nMyClass.open(function(proto) { proto.a = 2 });\nmyInst.a // => 2\nMyClass.open(function(proto, _super) { /* _super is Object.prototype here */ });\n\n// you can also use `.extend(definition)` to create new subclasses.  This is equivalent\n// to calling P with two arguments.\nvar Subclass = MyClass.extend({ a: 3 });\n```\n\n## how do i use pjs in node.js?\n\nAssuming you have it installed (via `npm install pjs`), you can import it with\n\n``` js\nvar P = require('pjs').P;\n```\n\nand go about your business.\n\n## what is all this Makefile stuff about\n\nIt's super useful! In addition to `make`, Pjs uses some build tools written on\n[Node][]. With the [Node Package Manager][npm] that comes with recent versions\nof it, just run\n\n    npm install\n\nfrom the root directory of the repo and `make` will start working.\n\n[Node]: http://nodejs.org/#download\n[npm]: http://npmjs.org\n\nHere are the things you can build:\n\n- `make minify`\n    generates `build/p.min.js`\n\n- `make commonjs`\n    generates `build/p.commonjs.js`, which is the same but has `exports.P = P` at the end\n\n- `make amd`\n    generates `build/p.amd.js`, which is the same but has `define(P)` at the end\n\n- `make test`\n    runs the test suite using the commonjs version.  Requires `mocha`.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/jneen/pjs/issues"
  },
  "_id": "pjs@5.1.1",
  "_from": "pjs@5.x"
}
