{
  "name": "parsimmon",
  "version": "0.4.0",
  "description": "A monadic LL(infinity) parser combinator library",
  "keywords": [
    "parsing",
    "parse",
    "parser combinators"
  ],
  "author": {
    "name": "Jay Adkisson",
    "email": "jjmadkisson at gmail dot com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/jayferd/parsimmon"
  },
  "files": [
    "index.js",
    "src",
    "test",
    "Makefile",
    "package.json",
    "build/parsimmon.commonjs.js",
    "build/parsimmon.browser.js",
    "build/parsimmon.browser.min.js"
  ],
  "main": "index.js",
  "devDependencies": {
    "mocha": "1.8.x",
    "chai": "1.5.x",
    "uglify-js": "2.x"
  },
  "dependencies": {
    "pjs": "5.x"
  },
  "scripts": {
    "test": "make test"
  },
  "readme": "[![Build Status](https://secure.travis-ci.org/jayferd/parsimmon.png)](http://travis-ci.org/jayferd/parsimmon)\n\n# Parsimmon\n\n[![Parsimmon](http://i.imgur.com/wyKOf.png)](http://github.com/jayferd/parsimmon)\n\n(by @jayferd and @laughinghan)\n\nParsimmon is a small library for writing big parsers made up of lots of little parsers.  The API is inspired by parsec and Promises/A.\n\n## Quick Example\n\n``` js\nvar regex = Parsimmon.regex;\nvar string = Parsimmon.string;\nvar optWhitespace = Parsimmon.optWhitespace;\nvar lazy = Parsimmon.lazy;\n\nfunction lexeme(p) { return p.skip(optWhitespace); }\n\nvar lparen = lexeme(string('('));\nvar rparen = lexeme(string(')'));\n\nvar expr = lazy(function() { return form.or(atom) });\n\nvar number = lexeme(regex(/[0-9]+/).map(parseInt));\nvar id = lexeme(regex(/[a-z_]\\w*/i));\n\nvar atom = number.or(id);\nvar form = lparen.then(expr.many()).skip(rparen);\n\nexpr.parse('3').value // => 3\nexpr.parse('(add (mul 10 (add 3 4)) (add 7 8))').value\n  // => ['add', ['mul', 10, ['add', 3, 4]], ['add', 7, 8]]\n```\n\n## Explanation\n\nA Parsimmon parser is an object that represents an action on a stream\nof text, and the promise of either an object yielded by that action on\nsuccess or a message in case of failure.  For example, `string('foo')`\nyields the string `'foo'` if the beginning of the stream is `'foo'`,\nand otherwise fails.\n\nThe combinator method `.map` is used to transform the yielded value.\nFor example,\n\n``` js\nstring('foo').map(function(x) { return x + 'bar'; })\n```\n\nwill yield `'foobar'` if the stream starts with `'foo'`.  The parser\n\n``` js\ndigits.map(function(x) { return parseInt(x) * 2; })\n```\n\nwill yield the number 24 when it encounters the string '12'.  The method\n`.result` can be used to set a constant result.\n\nCalling `.parse(str)` on a parser parses the string, and returns an\nobject with a `status` flag, indicating whether the parse succeeded.\nIf it succeeded, the `value` attribute will contain the yielded value.\nOtherwise, the `index` and `expected` attributes will contain the\nindex of the parse error, and a message indicating what was expected.\nThe error object can be passed along with the original source to\n`Parsimmon.formatError(source, error)` to obtain a human-readable\nerror string.\n\n## Full API\n\n### Included parsers / parser generators:\n  - `Parsimmon.string(\"my-string\")` is a parser that expects to find\n    `\"my-string\"`, and will yield the same.\n  - `Parsimmon.regex(/myregex/)` is a parser that expects the stream\n    to match the given regex.\n  - `Parsimmon.succeed(result)` is a parser that doesn't consume any of\n    the string, and yields `result`.\n  - `Parsimmon.seq(p1, p2, ... pn)` accepts a variable number of parsers \n    that it expects to find in order, yielding an array of the results.\n  - `Parsimmon.alt(p1, p2, ... pn)` accepts a variable number of parsers,\n    and yields the value of the first one that succeeds, backtracking in between.\n  - `Parsimmon.lazy(f)` accepts a function that returns a parser, which\n    is evaluated the first time the parser is used.  This is useful for\n    referencing parsers that haven't yet been defined.\n  - `Parsimmon.fail(message)`\n  - `Parsimmon.letter` is equivalent to `Parsimmon.regex(/[a-z]/i)`\n  - `Parsimmon.letters` is equivalent to `Parsimmon.regex(/[a-z]*/i)`\n  - `Parsimmon.digit` is equivalent to `Parsimmon.regex(/[0-9]/)`\n  - `Parsimmon.digits` is equivalent to `Parsimmon.regex(/[0-9]*/)`\n  - `Parsimmon.whitespace` is equivalent to `Parsimmon.regex(/\\s+/)`\n  - `Parsimmon.optWhitespace` is equivalent to `Parsimmon.regex(/\\s*/)`\n  - `Parsimmon.any` consumes and yields the next character of the stream.\n  - `Parsimmon.all` consumes and yields the entire remainder of the stream.\n  - `Parsimmon.eof` expects the end of the stream.\n  - `Parsimmon.index` is a parser that yields the current index of the parse.\n\n### Parser methods\n  - `parser.or(otherParser)`:\n    returns a new parser which tries `parser`, and if it fails uses `otherParser`.\n  - `parser.chain(function(result) { return anotherParser; })`:\n    returns a new parser which tries `parser`, and on success calls the\n    given function with the result of the parse, which is expected to\n    return another parser, which will be tried next.  This allows you\n    to dynamically decide how to continue the parse, which is impossible\n    with the other combinators.\n  - `parser.then(anotherParser)`:\n    expects `anotherParser` to follow `parser`, and yields the result\n    of `anotherParser`.  NB: the result of `parser` here is ignored.\n  - `parser.map(function(result) { return anotherResult; })`:\n    transforms the output of `parser` with the given function.\n  - `parser.skip(otherParser)`\n    expects `otherParser` after `parser`, but preserves the yield value\n    of `parser`.\n  - `parser.result(aResult)`:\n    returns a new parser with the same behavior, but which yields `aResult`.\n  - `parser.many()`:\n    expects `parser` zero or more times, and yields an array of the results.\n  - `parser.times(n)`:\n    expects `parser` exactly `n` times, and yields an array of the results.\n  - `parser.times(min, max)`:\n    expects `parser` between `min` and `max` times, and yields an array\n    of the results.\n  - `parser.atMost(n)`:\n    expects `parser` at most `n` times.  Yields an array of the results.\n  - `parser.atLeast(n)`:\n    expects `parser` at least `n` times.  Yields an array of the results.\n  - `parser.mark()` yields an object with `start`, `value`, and `end` keys, where\n    `value` is the original value yielded by the parser, and `start` and `end` are\n    the indices in the stream that contain the parsed text.\n\n## Tips and patterns\n\nThese apply to most parsers for traditional langauges - it's possible\nyou may need to do something different for yours!\n\nFor most parsers, the following format is helpful:\n\n1. define a `lexeme` function to skip all the stuff you don't care\n   about (whitespace, comments, etc).  You may need multiple types of lexemes.\n   For example,\n\n    ``` js\n    var ignore = whitespace.or(comment.many());\n    function lexeme(p) { return p.skip(ignore); }\n    ```\n\n1. Define all your lexemes first.  These should yield native javascript values.\n\n    ``` js\n    var lparen = lexeme(string('('));\n    var rparen = lexeme(string(')'));\n    var number = lexeme(regex(/[0-9]+/)).map(parseInt);\n    ```\n\n1. Forward-declare one or more top-level expressions with `lazy`,\n   referring to parsers that have not yet been defined.  Generally, this\n   takes the form of a large `.alt()` call\n\n    ``` js\n    var expr = lazy(function() { return Parsimmon.alt(p1, p2, ...); });\n    ```\n\n1. Then build your parsers from the inside out - these should return\n   AST nodes or other objects specific to your domain.\n\n    ``` js\n    var p1 = ...\n    var p2 = ...\n    ```\n\n1. Finally, export your top-level parser.  Remember to skip ignored\n   stuff at the beginning.\n\n    ``` js\n    return ignore.then(expr.many());\n    ```\n\n### Fantasyland\n\n[fantasyland]: https://github.com/fantasyland/fantasy-land \"Fantasyland\"\n[fantasyland-logo]: https://github.com/fantasyland/fantasy-land/raw/master/logo.png\n\n![][fantasyland-logo]\n\nParsimmon is also compatible with [fantasyland][].  It is a Semigroup, an Applicative Functor and a Monad.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/jayferd/parsimmon/issues"
  },
  "_id": "parsimmon@0.4.0",
  "_from": "parsimmon@^0.4.0"
}
