{
  "name": "barrage",
  "version": "1.1.0",
  "description": "Extensions to streams (as a mixin)",
  "keywords": [],
  "dependencies": {
    "promise": "^6.0.0"
  },
  "devDependencies": {
    "mocha": "*"
  },
  "scripts": {
    "test": "mocha -R spec"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/ForbesLindesay/barrage.git"
  },
  "author": {
    "name": "ForbesLindesay"
  },
  "license": "MIT",
  "readme": "# barrage\r\n\r\nExtensions to streams (as a mixin)\r\n\r\n[![Build Status](https://img.shields.io/travis/ForbesLindesay/barrage/master.svg)](https://travis-ci.org/ForbesLindesay/barrage)\r\n[![Dependency Status](https://img.shields.io/gemnasium/ForbesLindesay/barrage.svg)](https://gemnasium.com/ForbesLindesay/barrage)\r\n[![NPM version](https://img.shields.io/npm/v/barrage.svg)](http://badge.fury.io/js/barrage)\r\n\r\n## Installation\r\n\r\n    npm install barrage\r\n\r\n## API\r\n\r\nThe main export is `barrage(stream)` which adds the extension methods as helper methods to an existing stream.\r\n\r\nIt also exports the same API as the `v0.10` stream module with Readable, Writable, Duplex, Transform and PassThrough (except that each one is extended with the `barrage` extensions mixin).\r\n\r\nNote that no native modules are affected, all the extensions are safe to use with other non barrage code.\r\n\r\nThe following extensions are currently added to Barrage Streams:\r\n\r\n### barrage.syphon(stream, [options])\r\n\r\nThis is exactly like the built in `source.pipe(destination, [options])` except that it also forwards any errors emitted by `source` to the `destination`.  When your streams represent transformations, that is usually much more useful than the built in `.pipe`.\r\n\r\n### barrage.buffer([encoding], callback)\r\n\r\nWhen the barrage is a readable stream, this method buffers the results and handles errors, resulting in a node.js style `callback` API.  If there is no `encoding` parameter, the callback is called with an `Array` for the result.  If encoding is `'buffer'` then the callback is called with a single `Buffer` for the result.  If any other string is passed as `encoding`, the `encoding` parameter is passed on to `buffer.toString(encoding)` and the result is therefore a `String`\r\n\r\nIf the callback parameter is absent, a [Promises/A+](http://promises-aplus.github.io/promises-spec/) promise is returned instead.\r\n\r\n### barrage.wait(callback)\r\n\r\nThis works like `barrage.buffer`, except that it does not buffer the result.  It will wait for an `end` or `finish` event and then call the callback.  If an error event is fired, the callback is called with that error. The callback is only ever called once.\r\n\r\nIf the callback parameter is absent, a [Promises/A+](http://promises-aplus.github.io/promises-spec/) promise is returned instead.\r\n\r\n### barrage.map(transform, options) / new barrage.Map(transform, options)\r\n\r\nThis passes each chunk to `transform` and then pushes the result of calling `transform` to the output stream.  You can either call this as a method on an existing barrage stream, or create a `Transform` stream by calling `new barrage.Map`\r\n\r\ne.g.\r\n\r\n```js\r\nfunction square() {\r\n  return new barrage.Map(function (x) {\r\n    return x * x\r\n  })\r\n}\r\n```\r\n\r\nIt supports both being asynchronous, and parallel:\r\n\r\n```js\r\nfunction load() {\r\n  return new barrage.Map(function (stat, callback) {\r\n    fs.readFile(stat.fullPath, callback)\r\n  }, {parallel: 10})\r\n}\r\n```\r\n\r\nWhen operating in parallel, the ordering of the resulting stream is always preserved.\r\n\r\nIt also supports promises\r\n\r\n```js\r\nfunction load() {\r\n  return new barrage.Map(function (stat) {\r\n    return Promise.denodeify(fs.readFile)(stat.fullPath)\r\n  }, {parallel: 10})\r\n}\r\n```\r\n\r\n### barrage.filter(transform, options) / new barrage.Filter(transform, options)\r\n\r\nThis is exactly like `barrage.map` / `new barrage.Map` except that `transform` should return `true` or `false` and the chunks will be filtered based on that value.\r\n\r\n### barrage.flatMap(transform, options) / new barrage.FlatMap(transform, options)\r\n\r\nTake a function that maps an object onto an array or stream (or if `for...of` is supported by your version of node, any iterable), then return a stream for those individual items.  e.g.\r\n\r\n```js\r\nvar source = new b.Readable({objectMode: true});\r\nsource._read = function () {\r\n  this.push(1)\r\n  this.push(2)\r\n  this.push(3)\r\n  this.push(null)\r\n};\r\nsource.flatMap(function (x) {\r\n  var source = new b.Readable({objectMode: true})\r\n  source._read = function () {\r\n    this.push(x * 1) // 1, 2, 3\r\n    this.push(x * 2) // 2, 4, 6\r\n    this.push(null)\r\n  }\r\n  return source\r\n}).buffer().done(function (data) {\r\n    assert.deepEqual(data, [1, 2, 2, 4, 3, 6])\r\n    done()\r\n  })\r\n  ```\r\n\r\n### barrage.bufferTransform(transform, encoding) / new barrage.BufferTransform(transform, encoding)\r\n\r\nTakes a function that transforms a string and returns a `Transform` stream.  e.g.\r\n\r\n```js\r\nfunction coffeify(filename) {\r\n  return new barrage.BufferTransform(function (src) {\r\n    return compileCoffee(filename, src)\r\n  }, 'utf8')\r\n}\r\nfunction compileCoffee(filename, src) {\r\n  //do compilation and return a string\r\n}\r\nfs.createReadStream('src.coffee').pipe(coffeify('src.coffee')).pipe(fs.createWriteStream('src.js'))\r\n```\r\n\r\nThis is mostly useful for processing files over stdio and creating browserify transforms.\r\n\r\nThe `transform` function may optionally take a callback argument (if it returns `undefined`) or return a promise (instead of a string).\r\n\r\n## License\r\n\r\n  MIT\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/ForbesLindesay/barrage/issues"
  },
  "_id": "barrage@1.1.0",
  "_from": "barrage@~1.1.0"
}
