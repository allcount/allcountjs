// headings were generated by http://patorjk.com/software/taag/#p=display&f=Colossal&t=ValidateResponse
var assert = require('assert'),
	crypto = require('crypto'),
	rewire = require('rewire'),
	_ = require('underscore'),
	hashFiles = rewire('../lib/hash'),
	mockFiles = {
		'a/directory/': null,
		'z_file1.txt': new Buffer('some content'),
		'some/dir/file2.txt': new Buffer('some more content')
	},
	hash = function(data, algorithm) {
		var hash = crypto.createHash(algorithm);
		hash.update(data);
		return hash.digest('hex');
	},
	expectedRawContents = Buffer.concat([mockFiles['some/dir/file2.txt'], mockFiles['z_file1.txt']]);
	expectedContentsSha1 = hash(expectedRawContents, 'sha1'),
	expectedContentsMd5 = hash(expectedRawContents, 'md5'),
	failGlobbing = false,
	failReadFile = false,
	mockGlobFunc = function(dir, options, cb) {
		if (failGlobbing) {
			return cb(new Error());
		}
		// add a duplicate file for testing purposes (to make sure it gets removed)
		var files = _.keys(mockFiles);
		files.push(files[1]);
		cb(null, files);
	},
	mockGlobSyncFunc = function(dir, options) {
		if (failGlobbing) {
			throw new Error();
		}
		// add a duplicate file for testing purposes (to make sure it gets removed)
		var files = _.keys(mockFiles);
		files.push(files[1]);
		return files;
	},
	mockFsObj = {
		readFile: function(file, options, cb) {
			if (!cb) {
				cb = options;
			}
			if (failReadFile) {
				return cb(new Error());
			}
			cb(null, mockFiles[file]);
		},
		readFileSync: function(file, options, cb) {
			if (!cb) {
				cb = options;
			}
			if (failReadFile) {
				throw new Error();
			}
			return mockFiles[file];
		}
	};

mockGlobFunc.sync = mockGlobSyncFunc;


hashFiles.__set__('glob', mockGlobFunc);

hashFiles.__set__('fs', mockFsObj);

describe('hash-files Unit Tests', function() {

	beforeEach(function() {
		failGlobbing = false;
		failReadFile = false;
	});
	/*
	888                        888              .d888 d8b 888                   
	888                        888             d88P"  Y8P 888                   
	888                        888             888        888                   
	88888b.   8888b.  .d8888b  88888b.         888888 888 888  .d88b.  .d8888b  
	888 "88b     "88b 88K      888 "88b        888    888 888 d8P  Y8b 88K      
	888  888 .d888888 "Y8888b. 888  888 888888 888    888 888 88888888 "Y8888b. 
	888  888 888  888      X88 888  888        888    888 888 Y8b.          X88 
	888  888 "Y888888  88888P' 888  888        888    888 888  "Y8888   88888P'
	*/
	describe('hash-files', function() {

		it('should hash contents of directory with defaults', function(done) {
			hashFiles(function(err, hash) {
				assert(!err);
				assert(hash === expectedContentsSha1);
				done();
			});
		});

		it('should hash contents of files with md5 algorithm', function(done) {
			hashFiles({ files: ['/some/root/*'], algorithm: 'md5' }, function(err, hash) {
				assert(!err);
				assert(hash === expectedContentsMd5);
				done();
			});
		});

		it('should hash contents of files without globbing', function(done) {
			hashFiles({ files: ['z_file1.txt', 'some/dir/file2.txt'], noGlob: true }, function(err, hash) {
				assert(!err);
				assert(hash === expectedContentsSha1);
				done();
			});
		});

		it('should throw an error if params are missing', function(done) {
			assert.throws(hashFiles, /Missing or invalid/);
			done();
		});

		it('should throw an error if unknown algorithm', function(done) {
			assert.throws(function() {
				hashFiles({ algorithm: 'fnord' }, function(err, hash) {});
			}, /Invalid algorithm/);
			done();
		});

		it('should return error if globbing fails', function(done) {

			failGlobbing = true;

			hashFiles(function(err, hash) {
				assert(err);
				assert(!hash);
				done();
			});
		});

		it('should return error if readFiles fails', function(done) {

			failReadFile = true;

			hashFiles(function(err, hash) {
				assert(err);
				assert(!hash);
				done();
			});
		});

	});

	/*
	888                        888              .d888 d8b 888                                                              
	888                        888             d88P"  Y8P 888                                                              
	888                        888             888        888                                                              
	88888b.   8888b.  .d8888b  88888b.         888888 888 888  .d88b.  .d8888b         .d8888b  888  888 88888b.   .d8888b 
	888 "88b     "88b 88K      888 "88b        888    888 888 d8P  Y8b 88K             88K      888  888 888 "88b d88P"    
	888  888 .d888888 "Y8888b. 888  888 888888 888    888 888 88888888 "Y8888b. 888888 "Y8888b. 888  888 888  888 888      
	888  888 888  888      X88 888  888        888    888 888 Y8b.          X88             X88 Y88b 888 888  888 Y88b.    
	888  888 "Y888888  88888P' 888  888        888    888 888  "Y8888   88888P'         88888P'  "Y88888 888  888  "Y8888P 
	                                                                                                 888                   
	                                                                                            Y8b d88P                   
	                                                                                             "Y88P"     
	*/
	describe('hash-files-sync', function() {

		it('should hash contents of directory with defaults', function(done) {
			var hash = hashFiles.sync();
			assert(hash === expectedContentsSha1);
			done();
		});
		
		it('should hash contents of files with md5 algorithm', function(done) {
			var hash = hashFiles.sync({ files: ['/some/root/*'], algorithm: 'md5' });
			assert(hash === expectedContentsMd5);
			done();
		});

		it('should hash contents of files without globbing', function(done) {
			var hash = hashFiles.sync({ files: ['z_file1.txt', 'some/dir/file2.txt'], noGlob: true });
			assert(hash === expectedContentsSha1);
			done();
		});

		it('should throw an error if unknown algorithm', function(done) {
			assert.throws(function() {
				hashFiles.sync({ algorithm: 'fnord' });
			}, /Invalid algorithm/);
			done();
		});

		it('should throw an return error if globbing fails', function(done) {

			failGlobbing = true;

			assert.throws(function() {
				hashFiles.sync();
			});
			done();
		});

		it('should throw an error if readFiles fails', function(done) {

			failReadFile = true;

			assert.throws(function() {
				hashFiles.sync();
			});
			done();
		});
		
	});

});